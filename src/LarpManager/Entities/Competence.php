<?php

/**
 * LarpManager - A Live Action Role Playing Manager
 * Copyright (C) 2016 Kevin Polez
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Auto generated by MySQL Workbench Schema Exporter.
 * Version 2.1.6-dev (doctrine2-annotation) on 2015-08-15 13:14:22.
 * Goto https://github.com/johmue/mysql-workbench-schema-exporter for more
 * information.
 */

namespace LarpManager\Entities;

use Doctrine\Common\Collections\ArrayCollection;

/**
 * LarpManager\Entities\Competence
 *
 * @Entity(repositoryClass="LarpManager\Repository\CompetenceRepository")
 */
class Competence extends BaseCompetence
{
    public const PRETRISE = 'Prêtrise';
    public const NOBLESSE = 'Noblesse';
    public const ALCHIMIE = 'Alchimie';
    public const MAGIE = 'Magie';
    public const ARTISANAT = 'Artisanat';
    public const LITTERATURE = 'Littérature';

	public function __toString()
	{
		return $this->getLabel();	
	}
	
	/**
	 * Fourni la liste des personnages participants à un gn particulier
	 *
	 * @return \Doctrine\Common\Collections\Collection
	 */
	public function getPersonnagesGn($gnId)
	{
		$liste = new ArrayCollection();
		foreach (parent::getPersonnages() as $personnage)
		{
			foreach ( $personnage->getParticipants() as $participant)
			{
				$gn = $participant->getGn();
				if ( $gn )
				{
					if ( $gn->getId() == $gnId )
					{
						$liste[] = $participant;
					}
				}
			}
		}
		return $liste;
	}
	
	
	/**
	 * Fourni le label d'une compétence
	 */
	public function getLabel()
	{
		$label = $this->getCompetenceFamily()->getLabel();
		$label .= ' - ' . $this->getLevel()->getLabel();
		return $label;
	}

	public function getPrintLabel()
	{
		return preg_replace('/[^a-z0-9]+/', '_', strtolower($this->getLabel()));
	}
	
	public function getMaterielRaw()
	{
		return html_entity_decode(strip_tags($this->getMateriel()));
	}
	
	public function getDescriptionRaw()
	{
		return html_entity_decode(strip_tags($this->getDescription()));
	}
	
	/**
	 * Fourni la compétence de niveau immédiatement supérieur appartenant à la même famille de compétence
	 */
	public function getNext()
	{
		$competenceFamily = $this->getCompetenceFamily();
		$levelIndex = $this->getLevel()->getIndex();
		
		$competences = $competenceFamily->getCompetences();
		$nextCompetences = new ArrayCollection();
		
		foreach ( $competences as $competence)
		{			
			if ( $competence->getLevel()->getIndex() > $levelIndex )
			{
				$nextCompetences->add($competence);
			}
		}
		
		$minimumIndex = null ;
		$competenceFirst = null;
		foreach ( $nextCompetences as $competence )
		{
			if ( $minimumIndex == null)
			{
				$competenceFirst = $competence;
				$minimumIndex = $competence->getLevel()->getIndex();
			}
			else if ( $competence->getLevel()->getIndex() < $minimumIndex )
			{
				$competenceFirst = $competence;
				$minimumIndex = $competence->getLevel()->getIndex();
			}
		}
		
		return $competenceFirst;
	}
	
	
	public function getCompetenceAttributesAsString() 
	{	    
	    $r = "";	    
	    foreach ($this->getCompetenceAttributes() as $attribute ) {	        
	        $r = $r .  $attribute->getAttributeTypeId() . ":" . $attribute->getValue() . ";";
	    }	   
	    return $r;
	}
	
	public function findAttributeByTypeId($typeId) {
	    foreach($this->getCompetenceAttributes() as $attr) {
	        if($attr->getAttributeTypeId() == $typeId) {
	            return $attr;
	        }
	    }
	    return null;
	}
	
	public function setCompetenceAttributesAsString($value, $ormEm, $attributeRepos)
	{
	    $keepTypeIds  = array();	    
	    if($value != null) {

            $entries = explode(";", $value, 30);
            	    
            error_log("Set " . $value);
            
            foreach($entries as $entry) {
                
                $arrayIdValue = explode(":", $entry, 2);
                if(count($arrayIdValue) != 2)
                    continue;
                $typeId = intval($arrayIdValue[0]);
                $value = intval($arrayIdValue[1]);
                
                array_push($keepTypeIds, $typeId);
                $attr  = $this->findAttributeByTypeId($typeId);
                if($attr == null ) {	        
        	        $attr = new CompetenceAttribute();
        	        $attr->setCompetence($this);
        	        $attr->setCompetenceId($this->id);
        	        $attr->setAttributeTypeId($typeId);
        	        $attr->setAttributeType($attributeRepos->find($typeId));	        
        	        $attr->setValue(intval($value));	        	        	        	      
        	        $this->addCompetenceAttribute($attr);
                } else {
                    $attr->setValue($value);
                }
            }
	    } else {
	        // $value est null => $keepTypeIds est vide, on va donc tout supprimer.
	    }
	    
	    foreach($this->getCompetenceAttributes() as $attr) {
	        if(! in_array($attr->getAttributeTypeId(), $keepTypeIds)) {
	             error_log("Remove " . $attr->getAttributeTypeId());
	            $attributeType = $attr->getAttributeType();
	            $attributeType->removeCompetenceAttribute($attr);	            
	            $this->removeCompetenceAttribute($attr);
	            $ormEm->remove($attr);
	        }
	    }
	   
	   return $this;    
	}
	
	public function getAttributeValue($key) {
	    foreach($this->getCompetenceAttributes() as $attr) {
	        if($attr->getAttributeType()->getLabel() == $key) {
	            return $attr->getValue();
	        }
	    }
	    return null;
	}
}